---
name: implement
description: Read spec.md and implement the app — schema, functions, components. Use when the user says "implement", "build from spec", or has a spec.md ready.
allowed-tools: Read, Write, Edit, Bash, Glob, Grep
---

Read `spec.md` in the project root and implement the application. The spec is generated by the modeling tool (`bun model export-spec`) and contains stories, entities, documents, methods, permissions, relations, and change targets.

## Before you start

1. Read `spec.md` thoroughly. Understand every entity, document, method, and change target.
2. Check for a `## Metadata` section in `spec.md` — look for a **theme** entry which contains the user's visual style direction (colours, mood, design language). Use it to guide CSS variables and component styling.
3. Read the reference docs for implementation patterns:
   - `.claude/docs/database.md` — SQL conventions, save/remove pattern, notify payload
   - `.claude/docs/server.md` — WebSocket protocol, preAuth config
   - `.claude/docs/client.md` — session, signals, openDoc, merge, web components
   - `.claude/docs/css.md` — styling conventions
4. Read the existing app files to understand what's already in place:
   - `init_db/01_schema.sql`, `init_db/03_functions.sql`, `server.ts`
   - `components/app-home.ts`, `components/app-login.ts`

## Implementation order

Work through these layers in order. Each layer must be complete before moving to the next.

### 1. Schema (`init_db/01_schema.sql`)

Refer to `.claude/docs/database.md` for conventions.

For each entity in the spec (skip Account — that maps to the existing `user` table):

- Create a table with the fields listed. Map types: `number` → `INT` or `SERIAL PRIMARY KEY`, `string` → `TEXT`.
- Fields ending in `_id` are foreign keys — add `REFERENCES`.
- `id` is always `SERIAL PRIMARY KEY`.
- `created_at` / `updated_at` use `TIMESTAMPTZ NOT NULL DEFAULT now()`.
- Add indexes on foreign keys used in queries.

### 2. Doc functions (`init_db/03_functions.sql`)

Refer to `.claude/docs/database.md` for the doc function pattern and notify payload shape.

For each **document** in the spec:

- Create `<doc_name>(p_user_id INT, p_<root_entity>_id INT) RETURNS JSONB`.
- Public documents: skip the permission check but still take `p_user_id` (the server always prepends it).
- Collection documents: take no entity id, return `jsonb_build_object('<name>', COALESCE(jsonb_agg(...), '[]'))`.
- Build the JSON shape by following the expansion tree:
  - **has-many**: `COALESCE((SELECT jsonb_agg(row_to_json(x)::jsonb ORDER BY x.id) FROM ...), '[]'::jsonb)`
  - **belongs-to**: subselect a single `jsonb_build_object(...)` joined via the FK
  - **shallow**: same as has-many but don't recurse into nested expansions
- For nested expansions, use lateral joins or correlated subqueries.

### 3. Mutation functions (`init_db/03_functions.sql`)

Refer to `.claude/docs/database.md` for the save/remove pattern and notify payload.

For each **method** in the spec, create a postgres function following the four-step pattern:

1. **Resolve** — look up the entity
2. **Permission** — check the permission path (if any). The `@field` syntax means: start from the entity's column. `->table[filter].target` means join through that table. Check if `p_user_id` is in the result set.
3. **Mutate** — INSERT / UPDATE / DELETE
4. **Notify** — `pg_notify('change', ...)` with targets from the **Changes** section

#### Mapping methods to function names

- Methods that **create and update**: `save_<entity>` with `p_id INT DEFAULT NULL` — INSERT when null, UPDATE when given
- Methods that **only create** (e.g. sending a message): use the method name directly (e.g. `send_message`) — don't use `save_` with a dummy `p_id`
- Methods that update fields (publishes): `save_<entity>` with nullable field params
- Methods that delete: `remove_<entity>`
- Custom methods: use the method name as the function name (e.g. `publish_post`)

#### Input validation

Validate required text fields in mutation functions. Trim whitespace and reject empty strings:

```sql
IF TRIM(COALESCE(p_body, '')) = '' THEN
  RAISE EXCEPTION 'body is required';
END IF;
```

#### Mapping change targets to notify

Each line in the **Changes** section becomes a target in the notify payload:

```
`DocName(fk)` → `path` [intermediate_fks]
```

Maps to:

```sql
jsonb_build_object(
    'doc',        'doc_name',           -- lowercase doc name
    'collection', 'path',              -- the dotted path, or null for root
    'doc_id',     v_row.fk,            -- the first FK
    'parent_ids', jsonb_build_array(v_intermediate_fk1, ...)  -- only if intermediate FKs exist
)
```

For root entity changes (no path, just `DocName(id)`), use `'collection', null`. Data can be `row_to_json(v_row)::jsonb` — fields are spread onto the existing root.

For collection targets, the data **must match the doc shape** — include nested belongs-to objects and child arrays. The merge replaces the entire item in the array by `id`, so missing nested objects will be lost.

For collection documents (doc_id 0, e.g. a global feed), use `'doc_id', 0`.

#### Enriching notify data with helper functions

When a collection document has belongs-to expansions (e.g. a message list where each message has an `author`), every mutation that upserts into that collection must include the nested objects. Extract a **helper function** so the enrichment logic lives in one place:

```sql
-- Helper: enrich a message row to match the message shape in room_doc
CREATE OR REPLACE FUNCTION _enrich_message(p_row messages)
RETURNS JSONB LANGUAGE sql STABLE AS $$
  SELECT row_to_json(p_row)::jsonb || jsonb_build_object(
    'author', (SELECT jsonb_build_object('id', u.id, 'name', u.name)
               FROM "user" u WHERE u.id = p_row.sender_id)
  );
$$;
```

Then every mutation that touches messages calls `_enrich_message(v_row)` instead of duplicating the join:

```sql
-- In send_message:
v_data := _enrich_message(v_row);
PERFORM pg_notify('change', jsonb_build_object(
    'fn', 'send_message', 'op', 'upsert', 'data', v_data,
    'targets', jsonb_build_array(...)
)::text);
```

**When to create helpers:**
- If 2+ mutations upsert into the same collection and that collection has belongs-to or nested child expansions
- Name them `_enrich_<entity>` (the `_` prefix blocks client access)
- Place them in `init_db/03_functions.sql` before the mutations that use them

### 4. Seed data (`init_db/04_seed.sql`)

Create realistic seed data that exercises the stories. Include at least:
- 2-3 users with different roles (matching story actors)
- Enough entities to demonstrate each document and relationship

### 5. Server config (`server.ts`)

Refer to `.claude/docs/server.md` for the `createServer` config shape.

No changes needed unless the spec has pre-auth methods beyond login/register/accept_invite.

### 6. App entry point (`app.ts`)

Refer to `.claude/docs/client.md` for the boot sequence and session singleton.

**Read the existing `app.ts` first.** It already has the session singleton pattern (`bootSession`, `authRoute`, `sessionReady`). Just add new routes — don't rewrite it.

Add a route for each document that needs its own page:

```typescript
"/thing/:id": ({ id }) => authRoute(() => {
  const el = document.createElement("app-thing");
  el.setAttribute("thing-id", id);
  app.appendChild(el);
}),
```

Key points:
- **One WebSocket per app** — `initSession` creates it, `getSession` returns it from components
- `bootSession` must be called on login AND on reload (if token exists)
- `sessionReady` gates routes — because it's read inside the `routes()` effect, the router re-renders automatically when the session becomes ready
- Components never call `connect()` or `initSession()` — they call `getSession()`
- **Don't import component files that already exist** — only add imports for new components

### 7. Components

Refer to `.claude/docs/client.md` for the web component pattern, openDoc/closeDoc, and the `_error` sentinel.

**Read the existing components first.** If `app-home.ts` still uses `connect(token)`, update it to use `getSession()` instead — remove the `token` attribute, replace `connect(token)` with `getSession()`.

For each document, create or update components:

- **`components/app-home.ts`** — the authenticated shell. Open collection documents, render lists, navigate to detail views.
- **`components/app-<name>.ts`** — detail components for non-collection documents. Use `openDoc` to subscribe, `effect` to render, `api.save_*` / `api.remove_*` to mutate.

Follow the web component pattern from `.claude/docs/client.md`. The architecture is designed for **atomic, targeted updates** — never brute-force re-renders:

```
mutation → pg_notify → merge into signal → effect re-runs → patch specific DOM nodes
```

#### Component structure

1. **Build the static shell once** in `connectedCallback` — all HTML structure, forms, event listeners
2. **Effects only patch** — set `.textContent`, toggle classes, append/remove individual nodes
3. **Never replace innerHTML of a container inside an effect** — it destroys scroll position, focus, input state, and event listeners
4. **Never re-fetch a document after mutation** — the notify/merge cycle handles it automatically

```typescript
import { getSession } from "../session";
import { effect } from "../signals";

class AppThing extends HTMLElement {
  private disposers: (() => void)[] = [];

  connectedCallback() {
    const id = Number(this.getAttribute("thing-id"));
    const { api, status, openDoc } = getSession();

    // 1. Static shell — built once, never replaced
    this.innerHTML = `
      <header><h1 id="name"></h1></header>
      <ul id="items"></ul>
      <form id="add-form"><input name="title" /><button>Add</button></form>
    `;

    // 2. Event listeners — wired once, not inside effects
    this.querySelector("#add-form")!.addEventListener("submit", async (e) => {
      e.preventDefault();
      const input = this.querySelector<HTMLInputElement>("input[name=title]")!;
      const title = input.value.trim();
      if (!title) return;
      input.value = "";
      await api.save_item(null, id, title);
      // No DOM update here — notify/merge handles it
    });

    // 3. Effects — patch individual nodes, don't replace containers
    const doc = openDoc("thing_doc", id, null);
    let prevItemIds: number[] = [];

    this.disposers.push(effect(() => {
      const d = doc.get() as any;
      if (!d) return;
      if (d._error) {
        this.querySelector("#name")!.textContent = d._error;
        return;
      }
      if (d._removed) { location.hash = "/home"; return; }

      const thing = d.thing_doc;
      this.querySelector("#name")!.textContent = thing.name;

      // Reconcile list by id — don't replace innerHTML
      const ul = this.querySelector("#items")!;
      const currentIds = (thing.items ?? []).map((i: any) => i.id);
      for (const id of prevItemIds) {
        if (!currentIds.includes(id)) ul.querySelector(`[data-id="${id}"]`)?.remove();
      }
      for (const item of thing.items ?? []) {
        let li = ul.querySelector(`[data-id="${item.id}"]`) as HTMLElement | null;
        if (!li) {
          li = document.createElement("li");
          li.setAttribute("data-id", String(item.id));
          ul.appendChild(li);
        }
        li.textContent = item.title;
      }
      prevItemIds = currentIds;
    }));
  }

  disconnectedCallback() {
    this.disposers.forEach(d => d());
    this.disposers = [];
    getSession().closeDoc("thing_doc", Number(this.getAttribute("thing-id")));
  }
}
```

Key rules for components:
- Always use `getSession()` — never `connect(token)` or `initSession()`
- `openDoc` returns a signal that starts as `null` — always handle the `!d` case
- Always check for `d._error` and `d._removed` before accessing doc fields
- Always call `closeDoc` in `disconnectedCallback`
- `openDoc` is safe to call immediately — messages are queued until the WebSocket is open
- **Atomic updates, not brute-force** — effects patch individual DOM nodes (`.textContent`, append, remove). Never set `innerHTML` on a container inside an effect. Never re-fetch a document after calling a mutation.
- **Reconcile lists by id** — use `data-id` attributes. Add new items, update changed items, remove deleted items. Don't rebuild the list from scratch.
- **Shared utilities** — if multiple components need the same helper (e.g. HTML escaping, date formatting), extract it into a shared file rather than duplicating it in each component.
- **Scroll-aware lists** — for chat-like UIs, check if the user is near the bottom before auto-scrolling. Don't force-scroll when the user has scrolled up to read history.

### 8. Styles (`styles.css`)

Refer to `.claude/docs/css.md` for token conventions and component scoping.

If `spec.md` has a `## Metadata` section with a **theme** entry, use its description to guide colour choices, font selections, border styles, and overall mood. Translate the theme into CSS custom properties and component styles. If no theme entry exists, use sensible defaults.

## Key rules

- **Atomic updates** — the whole architecture is `mutation → notify → merge → effect → patch`. Effects must make targeted DOM changes (set textContent, append a node, remove a node). Never replace innerHTML of a container in an effect. Never re-fetch a document after a mutation. The merge cycle delivers the delta — trust it.
- **KISS** — keep it simple. Don't over-engineer. Write the minimum code that satisfies the spec. Prefer flat over nested, obvious over clever, fewer files over more.
- **DRY** — don't repeat yourself. If two mutations share the same permission check, extract a helper. If two components render lists the same way, factor out the pattern. If SQL functions share subqueries, use views or CTEs.
- **Read before writing** — always read existing files before modifying them. Don't duplicate code that already exists. Don't rewrite files that only need a few lines added.
- **Never edit** `server-core.ts`, `session.ts`, `signals.ts` — these are infrastructure.
- **Never edit** `init_db/02_auth.sql` unless auth needs customization.
- The `user` table already exists — map the spec's Account entity to it.
- Every mutation function's first parameter is `p_user_id INT` — the server injects it.
- Every doc function's first parameter is `p_user_id INT` — even for public docs.
- Notify targets must exactly match what clients subscribe to via `openDoc`.
- **Notify data must match the doc shape.** For root entity updates (`collection: null`), `row_to_json(v_row)::jsonb` is fine. For collection item upserts, build enriched data with nested objects (e.g. `row_to_json(v_row)::jsonb || jsonb_build_object('author', ..., 'children', ...)`). For removes, use `jsonb_build_object('id', v_id)`.
- **Session singleton**: components call `getSession()`, never `connect()` or `initSession()`. Upgrade `app-home.ts` from `connect(token)` to `getSession()` if needed.
- **Boot sequence**: `app.ts` owns `initSession` and `sessionReady`; routes gate on it via `authRoute`. Don't rewrite `app.ts` if it already has this pattern — just add routes.
- **openDoc starts null**: the server sends `op: "set"` with the full doc — components must handle `null` and `_error` before accessing fields.

## Presenting your plan

Before writing code, present a brief implementation plan showing:
1. Tables you'll create (with key columns)
2. Doc functions and their shapes
3. Mutation functions and their notify targets
4. Components you'll create

Ask the user to confirm before proceeding.
