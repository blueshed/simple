---
name: implement
description: Read spec.md and implement the app — schema, functions, components. Use when the user says "implement", "build from spec", or has a spec.md ready.
allowed-tools: Read, Write, Edit, Bash, Glob, Grep
---

Read `spec.md` in the project root and implement the application. The spec is generated by the modeling tool (`bun model export-spec`) and contains stories, entities, documents, methods, permissions, relations, and change targets.

## Before you start

1. Read `spec.md` thoroughly. Understand every entity, document, method, and change target.
2. Read the reference docs for implementation patterns:
   - `.claude/docs/database.md` — SQL conventions, save/remove pattern, notify payload
   - `.claude/docs/server.md` — WebSocket protocol, preAuth config
   - `.claude/docs/client.md` — session, signals, openDoc, merge, web components
   - `.claude/docs/css.md` — styling conventions
3. Read the existing app files to understand what's already in place:
   - `init_db/01_schema.sql`, `init_db/03_functions.sql`, `server.ts`
   - `components/app-home.ts`, `components/app-login.ts`

## Implementation order

Work through these layers in order. Each layer must be complete before moving to the next.

### 1. Schema (`init_db/01_schema.sql`)

Refer to `.claude/docs/database.md` for conventions.

For each entity in the spec (skip Account — that maps to the existing `user` table):

- Create a table with the fields listed. Map types: `number` → `INT` or `SERIAL PRIMARY KEY`, `string` → `TEXT`.
- Fields ending in `_id` are foreign keys — add `REFERENCES`.
- `id` is always `SERIAL PRIMARY KEY`.
- `created_at` / `updated_at` use `TIMESTAMPTZ NOT NULL DEFAULT now()`.
- Add indexes on foreign keys used in queries.

### 2. Doc functions (`init_db/03_functions.sql`)

Refer to `.claude/docs/database.md` for the doc function pattern and notify payload shape.

For each **document** in the spec:

- Create `<doc_name>(p_user_id INT, p_<root_entity>_id INT) RETURNS JSONB`.
- Public documents: skip the permission check but still take `p_user_id` (the server always prepends it).
- Collection documents: take no entity id, return `jsonb_build_object('<name>', COALESCE(jsonb_agg(...), '[]'))`.
- Build the JSON shape by following the expansion tree:
  - **has-many**: `COALESCE((SELECT jsonb_agg(row_to_json(x)::jsonb ORDER BY x.id) FROM ...), '[]'::jsonb)`
  - **belongs-to**: subselect a single `jsonb_build_object(...)` joined via the FK
  - **shallow**: same as has-many but don't recurse into nested expansions
- For nested expansions, use lateral joins or correlated subqueries.

### 3. Mutation functions (`init_db/03_functions.sql`)

Refer to `.claude/docs/database.md` for the save/remove pattern and notify payload.

For each **method** in the spec, create a postgres function following the four-step pattern:

1. **Resolve** — look up the entity
2. **Permission** — check the permission path (if any). The `@field` syntax means: start from the entity's column. `->table[filter].target` means join through that table. Check if `p_user_id` is in the result set.
3. **Mutate** — INSERT / UPDATE / DELETE
4. **Notify** — `pg_notify('change', ...)` with targets from the **Changes** section

#### Mapping methods to function names

- Methods that **create and update**: `save_<entity>` with `p_id INT DEFAULT NULL` — INSERT when null, UPDATE when given
- Methods that **only create** (e.g. sending a message): use the method name directly (e.g. `send_message`) — don't use `save_` with a dummy `p_id`
- Methods that update fields (publishes): `save_<entity>` with nullable field params
- Methods that delete: `remove_<entity>`
- Custom methods: use the method name as the function name (e.g. `publish_post`)

#### Input validation

Validate required text fields in mutation functions. Trim whitespace and reject empty strings:

```sql
IF TRIM(COALESCE(p_body, '')) = '' THEN
  RAISE EXCEPTION 'body is required';
END IF;
```

#### Mapping change targets to notify

Each line in the **Changes** section becomes a target in the notify payload:

```
`DocName(fk)` → `path` [intermediate_fks]
```

Maps to:

```sql
jsonb_build_object(
    'doc',        'doc_name',           -- lowercase doc name
    'collection', 'path',              -- the dotted path, or null for root
    'doc_id',     v_row.fk,            -- the first FK
    'parent_ids', jsonb_build_array(v_intermediate_fk1, ...)  -- only if intermediate FKs exist
)
```

For root entity changes (no path, just `DocName(id)`), use `'collection', null`. Data can be `row_to_json(v_row)::jsonb` — fields are spread onto the existing root.

For collection targets, the data **must match the doc shape** — include nested belongs-to objects and child arrays. Build enriched data: `row_to_json(v_row)::jsonb || jsonb_build_object('author', ..., 'children', ...)`. The merge replaces the entire item in the array by `id`, so missing nested objects will be lost.

For collection documents (doc_id 0, e.g. a global feed), use `'doc_id', 0`.

### 4. Seed data (`init_db/04_seed.sql`)

Create realistic seed data that exercises the stories. Include at least:
- 2-3 users with different roles (matching story actors)
- Enough entities to demonstrate each document and relationship

### 5. Server config (`server.ts`)

Refer to `.claude/docs/server.md` for the `createServer` config shape.

No changes needed unless the spec has pre-auth methods beyond login/register/accept_invite.

### 6. App entry point (`app.ts`)

Refer to `.claude/docs/client.md` for the boot sequence and session singleton.

**Read the existing `app.ts` first.** If it already has the session singleton pattern (`bootSession`, `authRoute`, `sessionReady`), just add new routes — don't rewrite it.

If it still uses the starter pattern (passing `token` as an attribute, no singleton), upgrade it:

1. Add imports: `signal`, `effect` from `"./signals"`, `initSession`, `clearSession` from `"./session"`
2. Add `bootSession(token)` and `authRoute(mount)` helpers (see `.claude/docs/client.md` Boot Sequence)
3. Add token restore: `const existingToken = getToken(); if (existingToken) bootSession(existingToken);`
4. Wire the login route to call `bootSession(e.detail.token)` then navigate
5. Wrap authenticated routes with `authRoute()`

Then add a route for each document that needs its own page:

```typescript
"/thing/:id": ({ id }) => authRoute(() => {
  const el = document.createElement("app-thing");
  el.setAttribute("thing-id", id);
  app.appendChild(el);
}),
```

Key points:
- **One WebSocket per app** — `initSession` creates it, `getSession` returns it from components
- `bootSession` must be called on login AND on reload (if token exists)
- `sessionReady` gates routes — because it's read inside the `routes()` effect, the router re-renders automatically when the session becomes ready
- Components never call `connect()` or `initSession()` — they call `getSession()`
- **Don't import component files that already exist** — only add imports for new components

### 7. Components

Refer to `.claude/docs/client.md` for the web component pattern, openDoc/closeDoc, and the `_error` sentinel.

**Read the existing components first.** If `app-home.ts` still uses `connect(token)`, update it to use `getSession()` instead — remove the `token` attribute, replace `connect(token)` with `getSession()`.

For each document, create or update components:

- **`components/app-home.ts`** — the authenticated shell. Open collection documents, render lists, navigate to detail views.
- **`components/app-<name>.ts`** — detail components for non-collection documents. Use `openDoc` to subscribe, `effect` to render, `api.save_*` / `api.remove_*` to mutate.

Follow the web component pattern from `.claude/docs/client.md`:

```typescript
import { getSession } from "../session";
import { effect } from "../signals";

class MyThing extends HTMLElement {
  private disposers: (() => void)[] = [];

  connectedCallback() {
    const id = Number(this.getAttribute("thing-id"));
    const { api, status, openDoc, closeDoc } = getSession();

    this.innerHTML = `<div id="content"><p>Loading…</p></div>`;

    const doc = openDoc("thing_doc", id, null);
    this.disposers.push(effect(() => {
      const d = doc.get() as any;
      if (!d) return;                    // null until server sends op:"set"
      if (d._error) {                    // permission denied or other error
        this.querySelector("#content")!.innerHTML =
          `<p style="color:var(--danger)">${d._error}</p>`;
        return;
      }
      if (d._removed) {                  // root entity was deleted
        location.hash = "/home";
        return;
      }
      const thing = d.thing_doc;
      this.querySelector("#content")!.innerHTML = `<p>${thing.name}</p>`;
    }));
  }

  disconnectedCallback() {
    this.disposers.forEach(d => d());
    this.disposers = [];
    getSession().closeDoc("thing_doc", Number(this.getAttribute("thing-id")));
  }
}
```

Key rules for components:
- Always use `getSession()` — never `connect(token)` or `initSession()`
- `openDoc` returns a signal that starts as `null` — always handle the `!d` case
- Always check for `d._error` and `d._removed` before accessing doc fields
- Always call `closeDoc` in `disconnectedCallback`
- `openDoc` is safe to call immediately — messages are queued until the WebSocket is open
- **Separate static UI from reactive effects** — event listeners on buttons/forms should be wired once in `connectedCallback`, not recreated inside effects. Effects should only update the parts of the DOM that change when data changes.
- **Shared utilities** — if multiple components need the same helper (e.g. HTML escaping, date formatting), extract it into a shared file rather than duplicating it in each component.
- **Scroll-aware lists** — for chat-like UIs, check if the user is near the bottom before auto-scrolling. Don't force-scroll when the user has scrolled up to read history.

### 8. Styles (`styles.css`)

Refer to `.claude/docs/css.md` for token conventions and component scoping.

Update CSS variables and add component styles as needed.

## Key rules

- **KISS** — keep it simple. Don't over-engineer. Write the minimum code that satisfies the spec. Prefer flat over nested, obvious over clever, fewer files over more.
- **DRY** — don't repeat yourself. If two mutations share the same permission check, extract a helper. If two components render lists the same way, factor out the pattern. If SQL functions share subqueries, use views or CTEs.
- **Read before writing** — always read existing files before modifying them. Don't duplicate code that already exists. Don't rewrite files that only need a few lines added.
- **Never edit** `server-core.ts`, `session.ts`, `signals.ts` — these are infrastructure.
- **Never edit** `init_db/02_auth.sql` unless auth needs customization.
- The `user` table already exists — map the spec's Account entity to it.
- Every mutation function's first parameter is `p_user_id INT` — the server injects it.
- Every doc function's first parameter is `p_user_id INT` — even for public docs.
- Notify targets must exactly match what clients subscribe to via `openDoc`.
- **Notify data must match the doc shape.** For root entity updates (`collection: null`), `row_to_json(v_row)::jsonb` is fine. For collection item upserts, build enriched data with nested objects (e.g. `row_to_json(v_row)::jsonb || jsonb_build_object('author', ..., 'children', ...)`). For removes, use `jsonb_build_object('id', v_id)`.
- **Session singleton**: components call `getSession()`, never `connect()` or `initSession()`. Upgrade `app-home.ts` from `connect(token)` to `getSession()` if needed.
- **Boot sequence**: `app.ts` owns `initSession` and `sessionReady`; routes gate on it via `authRoute`. Don't rewrite `app.ts` if it already has this pattern — just add routes.
- **openDoc starts null**: the server sends `op: "set"` with the full doc — components must handle `null` and `_error` before accessing fields.

## Presenting your plan

Before writing code, present a brief implementation plan showing:
1. Tables you'll create (with key columns)
2. Doc functions and their shapes
3. Mutation functions and their notify targets
4. Components you'll create

Ask the user to confirm before proceeding.
