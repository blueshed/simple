---
name: implement
description: Read spec.md and implement the app — schema, functions, components. Use when the user says "implement", "build from spec", or has a spec.md ready.
allowed-tools: Read, Write, Edit, Bash, Glob, Grep
---

Read `spec.md` in the project root and implement the application. The spec is generated by the modeling tool (`bun model export-spec`) and contains stories, entities, documents, methods, permissions, relations, and change targets.

## Before you start

1. Read `spec.md` thoroughly. Understand every entity, document, method, and change target.
2. Read the reference docs for implementation patterns:
   - `.claude/docs/database.md` — SQL conventions, save/remove pattern, notify payload
   - `.claude/docs/server.md` — WebSocket protocol, preAuth config
   - `.claude/docs/client.md` — session, signals, openDoc, merge, web components
   - `.claude/docs/css.md` — styling conventions
3. Read the existing app files to understand what's already in place:
   - `init_db/01_schema.sql`, `init_db/03_functions.sql`, `server.ts`
   - `components/app-home.ts`, `components/app-login.ts`

## Implementation order

Work through these layers in order. Each layer must be complete before moving to the next.

### 1. Schema (`init_db/01_schema.sql`)

Refer to `.claude/docs/database.md` for conventions.

For each entity in the spec (skip Account — that maps to the existing `user` table):

- Create a table with the fields listed. Map types: `number` → `INT` or `SERIAL PRIMARY KEY`, `string` → `TEXT`.
- Fields ending in `_id` are foreign keys — add `REFERENCES`.
- `id` is always `SERIAL PRIMARY KEY`.
- `created_at` / `updated_at` use `TIMESTAMPTZ NOT NULL DEFAULT now()`.
- Add indexes on foreign keys used in queries.

### 2. Doc functions (`init_db/03_functions.sql`)

Refer to `.claude/docs/database.md` for the doc function pattern and notify payload shape.

For each **document** in the spec:

- Create `<doc_name>(p_user_id INT, p_<root_entity>_id INT) RETURNS JSONB`.
- Public documents: skip the permission check but still take `p_user_id` (the server always prepends it).
- Collection documents: take no entity id, return `jsonb_build_object('<name>', COALESCE(jsonb_agg(...), '[]'))`.
- Build the JSON shape by following the expansion tree:
  - **has-many**: `COALESCE((SELECT jsonb_agg(row_to_json(x)::jsonb ORDER BY x.id) FROM ...), '[]'::jsonb)`
  - **belongs-to**: subselect a single `jsonb_build_object(...)` joined via the FK
  - **shallow**: same as has-many but don't recurse into nested expansions
- For nested expansions, use lateral joins or correlated subqueries.

### 3. Mutation functions (`init_db/03_functions.sql`)

Refer to `.claude/docs/database.md` for the save/remove pattern and notify payload.

For each **method** in the spec, create a postgres function following the four-step pattern:

1. **Resolve** — look up the entity
2. **Permission** — check the permission path (if any). The `@field` syntax means: start from the entity's column. `->table[filter].target` means join through that table. Check if `p_user_id` is in the result set.
3. **Mutate** — INSERT / UPDATE / DELETE
4. **Notify** — `pg_notify('change', ...)` with targets from the **Changes** section

#### Mapping methods to function names

- Methods that create: `save_<entity>` with `p_id INT DEFAULT NULL`
- Methods that update fields (publishes): `save_<entity>` with nullable field params
- Methods that delete: `remove_<entity>`
- Custom methods: use the method name as the function name (e.g. `publish_post`)

#### Mapping change targets to notify

Each line in the **Changes** section becomes a target in the notify payload:

```
`DocName(fk)` → `path` [intermediate_fks]
```

Maps to:

```sql
jsonb_build_object(
    'doc',        'doc_name',           -- lowercase doc name
    'collection', 'path',              -- the dotted path, or null for root
    'doc_id',     v_row.fk,            -- the first FK
    'parent_ids', jsonb_build_array(v_intermediate_fk1, ...)  -- only if intermediate FKs exist
)
```

For root entity changes (no path, just `DocName(id)`), use `'collection', null`. Data can be `row_to_json(v_row)::jsonb` — fields are spread onto the existing root.

For collection targets, the data **must match the doc shape** — include nested belongs-to objects and child arrays. Build enriched data: `row_to_json(v_row)::jsonb || jsonb_build_object('author', ..., 'children', ...)`. The merge replaces the entire item in the array by `id`, so missing nested objects will be lost.

For collection documents (doc_id 0, e.g. a global feed), use `'doc_id', 0`.

### 4. Seed data (`init_db/04_seed.sql`)

Create realistic seed data that exercises the stories. Include at least:
- 2-3 users with different roles (matching story actors)
- Enough entities to demonstrate each document and relationship

### 5. Server config (`server.ts`)

Refer to `.claude/docs/server.md` for the `createServer` config shape.

No changes needed unless the spec has pre-auth methods beyond login/register/accept_invite.

### 6. App entry point (`app.ts`)

Refer to `.claude/docs/client.md` for the boot sequence and session singleton.

The app must use the **session singleton** pattern:

```typescript
import { signal, effect, routes } from "./signals";
import { initSession, clearSession, getSession, getToken } from "./session";

const app = document.getElementById("app")!;
const sessionReady = signal(false);

function bootSession(token: string): void {
  clearSession();
  sessionReady.set(false);
  const session = initSession(token);
  let fired = false;
  effect(() => {
    if (session.profile.get() && !fired) {
      fired = true;
      sessionReady.set(true);
    }
  });
}

function authRoute(mount: () => void): void {
  if (!sessionReady.get()) {
    if (!getToken()) { location.hash = "/"; return; }
    app.innerHTML = `<p>Connecting…</p>`;
    return;
  }
  mount();
}

// Restore session from stored token on reload
const existingToken = getToken();
if (existingToken) bootSession(existingToken);
```

Then define routes, using `authRoute` to gate authenticated pages:

```typescript
routes(app, {
  "/": () => {
    const el = document.createElement("app-login");
    app.appendChild(el);
    el.addEventListener("authenticated", (e: any) => {
      bootSession(e.detail.token);
      location.hash = "/home";
    });
  },
  "/home": () => authRoute(() => {
    app.appendChild(document.createElement("app-home"));
  }),
  "/thing/:id": ({ id }) => authRoute(() => {
    const el = document.createElement("app-thing");
    el.setAttribute("thing-id", id);
    app.appendChild(el);
  }),
});
```

Key points:
- **One WebSocket per app** — `initSession` creates it, `getSession` returns it from components
- `bootSession` must be called on login AND on reload (if token exists)
- `sessionReady` gates routes — because it's read inside the `routes()` effect, the router re-renders automatically when the session becomes ready
- Components never call `connect()` or `initSession()` — they call `getSession()`

### 7. Components

Refer to `.claude/docs/client.md` for the web component pattern, openDoc/closeDoc, and the `_error` sentinel.

For each document, create or update components:

- **`components/app-home.ts`** — the authenticated shell. Open collection documents, render lists, navigate to detail views.
- **`components/app-<name>.ts`** — detail components for non-collection documents. Use `openDoc` to subscribe, `effect` to render, `api.save_*` / `api.remove_*` to mutate.

Follow the web component pattern from `.claude/docs/client.md`:

```typescript
import { getSession } from "../session";
import { effect } from "../signals";

class MyThing extends HTMLElement {
  private disposers: (() => void)[] = [];

  connectedCallback() {
    const id = Number(this.getAttribute("thing-id"));
    const { api, status, openDoc, closeDoc } = getSession();

    this.innerHTML = `<div id="content"><p>Loading…</p></div>`;

    const doc = openDoc("thing_doc", id, null);
    this.disposers.push(effect(() => {
      const d = doc.get() as any;
      if (!d) return;                    // null until server sends op:"set"
      if (d._error) {                    // permission denied or other error
        this.querySelector("#content")!.innerHTML =
          `<p style="color:var(--danger)">${d._error}</p>`;
        return;
      }
      const thing = d.thing_doc;
      this.querySelector("#content")!.innerHTML = `<p>${thing.name}</p>`;
    }));
  }

  disconnectedCallback() {
    this.disposers.forEach(d => d());
    this.disposers = [];
    getSession().closeDoc("thing_doc", Number(this.getAttribute("thing-id")));
  }
}
```

Key rules for components:
- Always use `getSession()` — never `connect(token)` or `initSession()`
- `openDoc` returns a signal that starts as `null` — always handle the `!d` case
- Always check for `d._error` before accessing doc fields
- Always call `closeDoc` in `disconnectedCallback`
- `openDoc` is safe to call immediately — messages are queued until the WebSocket is open

### 8. Styles (`styles.css`)

Refer to `.claude/docs/css.md` for token conventions and component scoping.

Update CSS variables and add component styles as needed.

## Key rules

- **Never edit** `server-core.ts`, `session.ts`, `signals.ts` — these are infrastructure.
- **Never edit** `init_db/02_auth.sql` unless auth needs customization.
- The `user` table already exists — map the spec's Account entity to it.
- Every mutation function's first parameter is `p_user_id INT` — the server injects it.
- Every doc function's first parameter is `p_user_id INT` — even for public docs.
- Notify targets must exactly match what clients subscribe to via `openDoc`.
- **Notify data must match the doc shape.** For root entity updates (`collection: null`), `row_to_json(v_row)::jsonb` is fine. For collection item upserts, build enriched data with nested objects (e.g. `row_to_json(v_row)::jsonb || jsonb_build_object('author', ..., 'children', ...)`). For removes, use `jsonb_build_object('id', v_id)`.
- **Session singleton**: components call `getSession()`, never `connect()` or `initSession()`.
- **Boot sequence**: `app.ts` owns `initSession` and `sessionReady`; routes gate on it via `authRoute`.
- **openDoc starts null**: the server sends `op: "set"` with the full doc — components must handle `null` and `_error` before accessing fields.

## Presenting your plan

Before writing code, present a brief implementation plan showing:
1. Tables you'll create (with key columns)
2. Doc functions and their shapes
3. Mutation functions and their notify targets
4. Components you'll create

Ask the user to confirm before proceeding.
